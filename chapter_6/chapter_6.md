# Chapter6

## 再レンダリングが起きる条件

### 再レンダリング

　再レンダリングが起きるのは以下の3つのパターンである。

1. Stateが更新されたコンポーネント
2. Propsが変更されたコンポーネント
3. 再レンダリングされたコンポーネント配下のコンポーネント全て

　1について、Stateはコンポーネントの状態を表す変数なので、更新された時に再レンダリングされないと画面の表示を正しく保つことができない。たとえばカウントアップの関数を実行してStateの更新によってコンポーネントが再レンダリングされているためである。

　2について、ReactコンポーネントはPropsを引数として受け取り、Propsに応じてレンダリング内容を決定するため、Propsの値が変わった時は再レンダリングして出力内容を必要がある。そのためPropsの値が変わった時は必ず再レンダリングが行われる。

　==「再レンダリングされたコンポーネント配下のコンポーネント全て」==とは、ルートコンポーネントがStateを更新した場合、その配下の全てのコンポーネントが再レンダリングされてしまうことを意味する。

　子のコンポーネントは特にPropsが変更されていなくてもデフォルトでは親が再レンダリングされたら再レンダリングされる。表示が変わらないのに毎回無駄な再レンダリングをしてしまうとパフォーマンスの低下を引き起こす原因になっている。



### React.memo

　Reactにおいて、コンポーネント、変数、関数などの再レンダリング時の制御をするには**メモ化**を行う。メモ化とは、前回の処理結果を保持しておくことで処理を高速化する技術である。必要な時のみ再計算をすることで不要な処理を省くことが可能になる。

`書式: memo`

```react
const Component = memo(() => {});
```

このようにすることで、このコンポーネントは==Propsに変更がない限り再レンダリングされない==ようになる。



### React.useCallback

　関数をPropsに渡す時にコンポーネントをメモ化していても再レンダリングされてしまう原因は**関数の再生成**である。

　以下のように関数を定義しているが、通常この場合は==再レンダリング等でこのコードが実行される度、常に新しい関数が再生成されている==ことになる。

`例: 関数の定義`

```react
const onClickReset = () => {
  setNum(0);
};
```

　そのため関数をPropsとして受け取っているコンポーネントは、==Propsが変化したと判定==してカウントアップの度に再レンダリングをしているということになる。この事象を回避するためには**関数のメモ化**を行う必要がある。

　useCallbackは==「第1引数に関数」,「第2引数にuseEffectと同じく依存配列」==をとる。

`書式: useCallback`

```react
const onClickButton = useCallback(() => {
  alert("ボタンが押されました");
}, []);
```

　この場合、依存配列は空なので関数は==最初に作成されたものが使い回される==ようになる。

